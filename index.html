<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fingerprint Features</title>

  <!-- keep your CSS file -->
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header>
    <h1>Fingerprint Features</h1>
  </header>

  <main>
    <div class="container">
      <ul id="featureList" class="list"></ul>
    </div>
  </main>

  <script>
    // Utility: append a feature card to the list
    function addFeature(title, value) {
      const ul = document.getElementById('featureList');
      const li = document.createElement('li');
      li.className = 'card';
      const safeVal = (typeof value === 'string' || typeof value === 'number')
        ? String(value)
        : JSON.stringify(value, null, 2);
      li.innerHTML = '<h3>' + escapeHtml(title) + '</h3><pre>' + escapeHtml(safeVal) + '</pre>';
      ul.appendChild(li);
    }

    function escapeHtml(s) {
      return String(s)
        .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;').replace(/'/g,'&#039;');
    }

    // SHA-256 helper (returns hex)
    // used to turn high-entropy raw data (like canvas pixel bytes or audio samples) into a stable short identifier that can be displayed or compared
    async function sha256Hex(input) {
      const data = (typeof input === 'string') ? new TextEncoder().encode(input) : input;
      const hash = await crypto.subtle.digest('SHA-256', data);
      return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2,'0')).join('');
    }

    // ===========================================================
    // HIGH ENTROPY FEATURES (Most Identifying)
    // ===========================================================

    // 1. Canvas Fingerprint (GPU/driver/font rendering differences)
    (async function canvasFingerprint() {
      try {
        const canvas = document.createElement('canvas');
        canvas.width = 240; canvas.height = 60;
        const ctx = canvas.getContext('2d');
        ctx.textBaseline = "top";
        ctx.font = "16px 'Arial'";
        ctx.fillText("Hello Fingerprint!", 2, 2);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data.buffer;
        const hash = await sha256Hex(imageData);
        addFeature("Canvas Fingerprint (SHA-256)", hash);
      } catch {
        addFeature("Canvas Fingerprint", "Blocked");
      }
    })();

    // 2. WebGL Fingerprint (GPU vendor, renderer, supported extensions)
    (function webglFingerprint() {
      try {
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (!gl) return addFeature("WebGL", "Not supported");
        const ext = gl.getExtension("WEBGL_debug_renderer_info");
        const vendor = ext ? gl.getParameter(ext.UNMASKED_VENDOR_WEBGL) : "N/A";
        const renderer = ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : "N/A";
        addFeature("WebGL Vendor", vendor);
        addFeature("WebGL Renderer", renderer);
        addFeature("WebGL Extensions (sample)", (gl.getSupportedExtensions() || []).slice(0,10).join(", "));
      } catch {
        addFeature("WebGL", "Blocked");
      }
    })();

    // 3. AudioContext Fingerprint (subtle differences in audio processing chain)
    (async function audioFingerprint() {
      try {
        const OfflineCtx = window.OfflineAudioContext || window.webkitOfflineAudioContext;
        if (!OfflineCtx) return addFeature("AudioContext", "Not supported");
        const ctx = new OfflineCtx(1, 44100, 44100);
        const osc = ctx.createOscillator();
        osc.connect(ctx.destination);
        osc.start();
        ctx.startRendering();
        const rendered = await new Promise(res => ctx.oncomplete = e => res(e.renderedBuffer));
        const hash = await sha256Hex(rendered.getChannelData(0).buffer);
        addFeature("AudioContext Fingerprint (SHA-256)", hash);
      } catch {
        addFeature("AudioContext", "Blocked");
      }
    })();

    // 4. Fonts / Font Rendering Differences
    (function fontProbe() {
      try {
        const testString = "mmmmmmmmmlliI@@##";
        const baseFonts = ["monospace", "serif", "sans-serif"];
        const fontsToTest = ["Arial", "Times New Roman", "Courier New", "Roboto"];
        function getWidth(font) {
          const span = document.createElement("span");
          span.style.font = "16px " + font;
          span.textContent = testString;
          document.body.appendChild(span);
          const w = span.getBoundingClientRect().width;
          document.body.removeChild(span);
          return w;
        }
        const baseline = {};
        baseFonts.forEach(f => baseline[f] = getWidth(f));
        const detected = fontsToTest.filter(f => {
          const w = getWidth(f + ", " + baseFonts.join(","));
          return !baseFonts.some(b => Math.abs(w - baseline[b]) < 0.1);
        });
        addFeature("Detected Fonts (sample)", detected.join(", ") || "None");
      } catch {
        addFeature("Fonts", "Blocked");
      }
    })();

    // 5. User-Agent (browser + OS + version)
    addFeature("User-Agent", navigator.userAgent);

    // ===========================================================
    // MEDIUM ENTROPY FEATURES
    // ===========================================================

    // 6. Screen Resolution + DPR + Color Depth
    addFeature("Screen Resolution", screen.width + " x " + screen.height);
    addFeature("Device Pixel Ratio", window.devicePixelRatio);
    addFeature("Color Depth", screen.colorDepth);

    // 7. Time Zone & Locale
    addFeature("Time Zone", Intl.DateTimeFormat().resolvedOptions().timeZone);
    addFeature("Locale", Intl.NumberFormat().resolvedOptions().locale);

    // 8. Platform String (OS architecture)
    addFeature("Platform", navigator.platform);

    // 9. Hardware Concurrency (logical cores)
    addFeature("CPU Cores", navigator.hardwareConcurrency || "N/A");

    // 10. Device Memory (RAM, in GB)
    addFeature("Device Memory", navigator.deviceMemory || "N/A");

    // ===========================================================
    // NETWORK FEATURES
    // ===========================================================

    // 11. WebRTC IP Candidates (may reveal local/public IPs if not blocked)
    (function webrtcIPs() {
      try {
        const pc = new RTCPeerConnection();
        pc.createDataChannel("");
        pc.onicecandidate = (e) => {
          if (e.candidate) addFeature("WebRTC ICE Candidate", e.candidate.candidate);
        };
        pc.createOffer().then(o => pc.setLocalDescription(o));
        setTimeout(() => pc.close(), 1500);
      } catch {
        addFeature("WebRTC", "Blocked");
      }
    })();

    // ===========================================================
    // LOWER ENTROPY / CONTEXTUAL
    // ===========================================================

    addFeature("Accept-Language", navigator.language);
    addFeature("Do Not Track", navigator.doNotTrack || "N/A");
    addFeature("Plugins (sample)", (navigator.plugins && navigator.plugins.length) ? navigator.plugins[0].name : "None");

    // Behavioral samples (mouse/key timing â€“ demo only)
    (function behavioralSample() {
      const mouseMoves = [];
      window.addEventListener("mousemove", e => {
        if (mouseMoves.length < 5) mouseMoves.push(`${e.clientX},${e.clientY}`);
      });
      setTimeout(() => addFeature("Mouse Movement Sample", mouseMoves.join(" | ") || "No data"), 3000);
    })();

    // WebAssembly performance micro-benchmark
    (async function wasmPerf() {
      try {
        const start = performance.now();
        const mod = await WebAssembly.compile(new Uint8Array([0,97,115,109,1,0,0,0]));
        await WebAssembly.instantiate(mod);
        const duration = performance.now() - start;
        addFeature("WASM Compile Time (ms)", duration.toFixed(2));
      } catch {
        addFeature("WebAssembly Perf", "Not supported");
      }
    })();

  </script>
</body>
</html>